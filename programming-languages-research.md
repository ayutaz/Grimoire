# プログラミング言語調査レポート

## 目次
1. [革新的なコンパイル型言語の特徴](#革新的なコンパイル型言語の特徴)
2. [趣味的・芸術的プログラミング言語](#趣味的芸術的プログラミング言語)
3. [新しい言語のアイデア](#新しい言語のアイデア)

---

## 革新的なコンパイル型言語の特徴

### 1. Rust - 所有権とメモリ安全性
- **所有権システム**: ガベージコレクタなしでメモリ管理を実現
- **借用チェッカー**: コンパイル時にメモリ安全性を保証
- **トレイトシステム**: 柔軟な抽象化を提供
- **ゼロコスト抽象化**: 実行時オーバーヘッドなしで高レベルな記述が可能
- **Fearless Concurrency**: 所有権システムによりデータ競合を防止

### 2. Zig - コンパイル時実行
- **comptime**: コンパイル時に任意のコードを実行
- **型の動的生成**: コンパイル時に型を生成・操作可能
- **エラー処理**: 例外なし、明示的なエラー伝播
- **C/C++との相互運用性**: シームレスな統合
- **手動メモリ管理**: 予測可能なパフォーマンス

### 3. Nim - メタプログラミングと柔軟性
- **強力なマクロシステム**: AST操作による柔軟なコード生成
- **テンプレート**: コンパイル時の定数置換
- **統一関数呼び出し構文（UFCS）**: 柔軟な構文
- **Pythonライクな構文**: 読みやすさを重視
- **複数のバックエンド**: C、C++、JavaScriptへのコンパイル

### 4. V - シンプルさとパフォーマンス
- **極めてシンプルな設計**: 週末で学習可能
- **高速コンパイル**: 1秒以下でセルフコンパイル
- **メモリ管理オプション**: GC、autofree、手動管理を選択可能
- **安全性機能**: 未定義動作なし、グローバル変数なし
- **C言語変換**: 既存のCプロジェクトを自動変換

### 5. Carbon - C++との相互運用性
- **双方向互換性**: C++コードとシームレスに統合
- **移行ツール**: 既存コードの段階的移行をサポート
- **パッケージマネージャ**: C++に欠けていた機能を提供
- **LLVM基盤**: C++と同等のパフォーマンス
- **穏やかな学習曲線**: C++開発者向けに設計

### 6. Odin - データ指向設計
- **組み込みSOAサポート**: `#soa`による自動メモリレイアウト変換
- **AOS/SOA切り替え**: 同じ構文で両方のアクセス方式をサポート
- **SOAスライス・動的配列**: 柔軟なデータ構造
- **soa_zip**: 複数のスライスを統合的に扱う
- **SIMD最適化**: データ並列処理に最適化

---

## 趣味的・芸術的プログラミング言語

### 猫系言語

#### LOLCODE
```lolcode
HAI 1.2
CAN HAS STDIO?
VISIBLE "HAI WORLD!"
KTHXBYE
```
- インターネットミーム「lolcat」に基づく言語
- `I CAN HAS`、`KTHXBYE`などの猫語キーワード
- チューリング完全な実装

#### Meowlang
- 猫の鳴き声でプログラミング
- `mew mew mew`の組み合わせでコードを表現

### 日本語プログラミング言語

#### なでしこ
```なでしこ
「こんにちは」と表示する。
もし、時間が12時以上ならば
    「こんばんは」と表示する。
ここまで。
```
- 自然な日本語でプログラミング
- 助詞による自動トークン分割
- 教育用途で中学校教科書に採用

#### プロデル
- オブジェクト指向の日本語プログラミング言語
- .NET CLR上で動作
- Webアプリケーション開発も可能

#### ドリトル
- 教育特化型言語
- タートルグラフィックス
- ブラウザから直接実行可能

### 視覚的・芸術的言語

#### Piet
- プログラムが抽象画のように見える
- 色の変化がコマンドを表現
- 円を描いて円周率を計算するプログラムが有名

#### Shakespeare
- プログラムがシェイクスピア劇のように見える
- 登場人物が変数、セリフが命令

#### Chef
- プログラムが料理レシピの形式
- スタック指向言語
- 材料がデータ、調理法が操作

#### Whitespace
- 空白文字（スペース、タブ、改行）のみを使用
- 他の文字は全て無視される
- 見えないプログラム

#### Emojicode
```emojicode
🏁 🍇
  😀 🔤Hello World!🔤❗️
🍉
```
- 絵文字でプログラミング
- チューリング完全
- 型安全な実装

---

## 新しい言語のアイデア

### 実用的な革新的機能の組み合わせ

1. **コンパイル時実行＋型システム融合**
   - ZigのcomptimeとRustの型システムを統合
   - データベーススキーマから型を自動生成

2. **メモリレイアウト変換機能**
   - 実行時の最適化に基づくAOS/SOA自動切り替え
   - キャッシュ効率の自動分析

3. **段階的相互運用性**
   - 関数単位で言語を混在可能
   - 既存コードの漸進的移行

4. **視覚的構文拡張**
   - 数式や図表を直接埋め込み可能
   - `∑(i=0..n) { array[i] }`のような数学記法

5. **エラー予測システム**
   - コンパイル時のエラーパターン学習
   - 確率的エラー予測と修正提案

6. **時間軸メモリ管理**
   - 時間ベースの借用チェック
   - リアルタイムシステム向け最適化

### 創造的・芸術的な言語アイデア

#### 🐱 にゃんこ言語（Nyanco）
```nyanco
にゃん 数字 = 42
みゃー 表示(数字)
ごろごろ (10回) {
    ふみふみ (数字 > 0) {
        みゃー かわいい()
    }
}
```

#### 🌸 はなことば（Hanakotoba）
```hanakotoba
桜咲く
    紫陽花 色 = ["赤", "青", "紫"]
    向日葵 (色の中) {
        薔薇 見せる(色)
    }
    椿落つ {
        菊 慰める()
    }
桜散る
```

#### ⭐ 魔法陣言語（MagicCircle）
- 視覚的プログラミング
- 魔法陣の模様がコードを表現
- 円の大きさ = スコープ
- 色の組み合わせ = データ型

#### 🍜 レシピ言語（Reshipi）
```reshipi
【材料】
- 数値 大さじ3
- 文字列 少々

【作り方】
1. 数値を細かく切る
2. 文字列と混ぜ合わせる
3. 5分煮込む
4. 味見して確認
5. 器に盛り付ける
```

#### 🎌 絵文字道（Emojido）
```emojido
🔢 年齢 = 2️⃣0️⃣
📝 名前 = "太郎"
✅ 成人 = 年齢 >= 1️⃣8️⃣
🔄 (成人) {
    📢 "成人です"
}
🗑️ 名前
```

#### 🎭 歌舞伎言語（Kabuki）
```kabuki
【第一幕】 計算の場
    花道を通る 主人公(数値甲, 数値乙) {
        見得を切る  // デバッグポイント
        立ち回り {  // 並行処理
            甲 + 乙
        }
    }
    幕が下りる
```

---

## コンパイラ作成ガイド

### コンパイラの基本構造

#### 1. レキサー（字句解析器）
- ソースコードを読み込み、トークンに分割
- 空白やコメントを除去し、意味のある単位（識別子、数値、演算子など）を抽出
- 例：`にゃん 数字 = 42` → `[NYAN, IDENTIFIER(数字), EQUALS, NUMBER(42)]`

#### 2. パーサー（構文解析器）
- トークンを受け取り、文法規則に従ってAST（抽象構文木）を構築
- 構文エラーを検出
- 再帰下降パーサーと演算子優先順位パーサーの組み合わせが一般的

#### 3. AST（抽象構文木）
- プログラムの構造を木構造で表現
- 文法規則ではなく、意味的な構造を表す
- パースツリーよりもコンパクトで処理しやすい

### バックエンドの選択肢

#### 1. LLVM
- **メリット**: 最適化が強力、多くの言語で採用実績、JITサポート
- **デメリット**: 巨大（ソース1.3GB、ビルド後12GB）、GC実装が困難
- **適用例**: Rust、Swift、Julia、Kotlin

#### 2. C言語へのトランスパイル
- **メリット**: 移植性が高い、デバッグしやすい、既存のCツールチェーンを活用
- **デメリット**: 最適化の制御が限定的、実行時エラーの扱いが難しい
- **適用例**: Nim、初期のC++

#### 3. 独自バイトコード + VM
- **メリット**: 完全な制御、軽量、インタプリタとの統合が容易
- **デメリット**: 最適化を自分で実装、JITは複雑
- **適用例**: Python、Ruby、Lua

### パーサージェネレータの比較

#### ANTLR
- 強力な機能、IDE統合、複雑な文法に対応
- LL(*)アルゴリズム、良好なエラーメッセージ
- 業界での採用多数（Hibernate、Twitter）

#### Yacc/Bison
- 歴史が長く安定、大学教育で主流
- LALR(1)パーサー、メモリ効率が良い
- しかし機能面では最も貧弱

#### PEG（Parsing Expression Grammar）
- 文法が明確で読みやすい
- バックトラッキングによる柔軟な解析
- 左再帰の扱いに注意が必要

#### パーサーコンビネータ（Parsec等）
- 既存のパーサーを組み合わせて新しいパーサーを作成
- 関数型言語で人気
- 文法の再利用性が高い

### 簡単な実装から始める

#### 推奨される学習パス

1. **Lispインタプリタ**
   - 構文が単純（括弧のみ）
   - パースが容易
   - 「Build Your Own Lisp」や「Lispy」が参考になる

2. **「Crafting Interpreters」**
   - 完全なコード付き
   - JavaとCの両方の実装
   - バイトコードVMまでカバー

3. **言語の選択**
   - パターンマッチングのある言語（Rust、OCaml、Haskell）推奨
   - AST操作が直感的に書ける

### 実装のヒント

1. **最小限から始める**
   - 四則演算と変数だけの言語から
   - 徐々に機能を追加（条件分岐、ループ、関数）

2. **テスト駆動開発**
   - 各段階でテストケースを書く
   - パーサーのテストは特に重要

3. **エラーメッセージ**
   - 位置情報（行番号、列番号）を保持
   - わかりやすいエラーメッセージを心がける

4. **デバッグツール**
   - AST視覚化ツールを作る
   - トークンストリームを出力する機能

---

## まとめ

現代のコンパイル型言語は、メモリ安全性、コンパイル時実行、データ指向設計など、様々な革新的機能を持っています。一方、趣味的・芸術的言語は、プログラミングの楽しさや創造性を追求しています。

これらの要素を組み合わせることで、実用性と楽しさを兼ね備えた新しいプログラミング言語を作ることができるでしょう。特に、日本の文化的要素（猫、花、歌舞伎など）を取り入れることで、独自性のある言語設計が可能です。

コンパイラ作成は複雑に見えますが、小さく始めて段階的に機能を追加していくことで、独自の言語を実現できます。LLVMやC言語へのトランスパイルなど、既存の技術を活用することで、実用的なコンパイラを効率的に開発できます。