package compiler

import (
	"strings"
	"testing"

	"github.com/ayutaz/grimoire/internal/parser"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestCompilerCreation tests that we can create a new compiler
func TestCompilerCreation(t *testing.T) {
	compiler := NewCompiler()
	assert.NotNil(t, compiler)
	assert.Equal(t, 0, compiler.indent)
	assert.Equal(t, "    ", compiler.indentStr)
}

// TestCompile_EmptyProgram tests compiling empty program
func TestCompile_EmptyProgram(t *testing.T) {
	ast := &parser.Program{
		HasOuterCircle: true,
		Functions:      []*parser.FunctionDef{},
		Globals:        []parser.Statement{},
	}

	code, err := Compile(ast)
	
	require.NoError(t, err)
	assert.Contains(t, code, "#!/usr/bin/env python3")
	assert.Contains(t, code, "Generated by Grimoire")
}

// TestCompile_HelloWorld tests compiling hello world program
func TestCompile_HelloWorld(t *testing.T) {
	ast := &parser.Program{
		HasOuterCircle: true,
		MainEntry: &parser.FunctionDef{
			IsMain: true,
			Body: []parser.Statement{
				&parser.OutputStatement{
					Value: &parser.Literal{
						Value:       "Hello, World!",
						LiteralType: parser.String,
					},
				},
			},
		},
	}

	code, err := Compile(ast)
	
	require.NoError(t, err)
	assert.Contains(t, code, `if __name__ == "__main__":`)
	assert.Contains(t, code, `print("Hello, World!")`)
}

// TestCompile_Arithmetic tests compiling arithmetic operations
func TestCompile_Arithmetic(t *testing.T) {
	ast := &parser.Program{
		HasOuterCircle: true,
		MainEntry: &parser.FunctionDef{
			IsMain: true,
			Body: []parser.Statement{
				&parser.OutputStatement{
					Value: &parser.BinaryOp{
						Left:     &parser.Literal{Value: 1, LiteralType: parser.Integer},
						Operator: parser.Add,
						Right:    &parser.Literal{Value: 2, LiteralType: parser.Integer},
						DataType: parser.Integer,
					},
				},
			},
		},
	}

	code, err := Compile(ast)
	
	require.NoError(t, err)
	assert.Contains(t, code, "print((1 + 2))")
}

// TestCompileLiteral tests literal compilation
func TestCompileLiteral(t *testing.T) {
	compiler := NewCompiler()
	
	tests := []struct {
		literal  *parser.Literal
		expected string
	}{
		{&parser.Literal{Value: 42, LiteralType: parser.Integer}, "42"},
		{&parser.Literal{Value: 3.14, LiteralType: parser.Float}, "3.14"},
		{&parser.Literal{Value: "hello", LiteralType: parser.String}, `"hello"`},
		{&parser.Literal{Value: true, LiteralType: parser.Boolean}, "True"},
		{&parser.Literal{Value: false, LiteralType: parser.Boolean}, "False"},
	}
	
	for _, tc := range tests {
		result := compiler.compileLiteral(tc.literal)
		assert.Equal(t, tc.expected, result)
	}
}

// TestCompileBinaryOp tests binary operation compilation
func TestCompileBinaryOp(t *testing.T) {
	compiler := NewCompiler()
	
	tests := []struct {
		op       parser.OperatorType
		expected string
	}{
		{parser.Add, "(1 + 2)"},
		{parser.Subtract, "(1 - 2)"},
		{parser.Multiply, "(1 * 2)"},
		{parser.Divide, "(1 / 2)"},
		{parser.Equal, "(1 == 2)"},
		{parser.NotEqual, "(1 != 2)"},
		{parser.LessThan, "(1 < 2)"},
		{parser.GreaterThan, "(1 > 2)"},
		{parser.And, "(1 and 2)"},
		{parser.Or, "(1 or 2)"},
	}
	
	for _, tc := range tests {
		binOp := &parser.BinaryOp{
			Left:     &parser.Literal{Value: 1, LiteralType: parser.Integer},
			Operator: tc.op,
			Right:    &parser.Literal{Value: 2, LiteralType: parser.Integer},
		}
		result := compiler.compileBinaryOp(binOp)
		assert.Equal(t, tc.expected, result)
	}
}

// TestCompileIfStatement tests if statement compilation
func TestCompileIfStatement(t *testing.T) {
	ast := &parser.Program{
		HasOuterCircle: true,
		MainEntry: &parser.FunctionDef{
			IsMain: true,
			Body: []parser.Statement{
				&parser.IfStatement{
					Condition: &parser.Literal{Value: true, LiteralType: parser.Boolean},
					ThenBranch: []parser.Statement{
						&parser.OutputStatement{
							Value: &parser.Literal{Value: "True", LiteralType: parser.String},
						},
					},
					ElseBranch: []parser.Statement{
						&parser.OutputStatement{
							Value: &parser.Literal{Value: "False", LiteralType: parser.String},
						},
					},
				},
			},
		},
	}

	code, err := Compile(ast)
	
	require.NoError(t, err)
	assert.Contains(t, code, "if True:")
	assert.Contains(t, code, `print("True")`)
	assert.Contains(t, code, "else:")
	assert.Contains(t, code, `print("False")`)
}

// TestIndentation tests proper indentation
func TestIndentation(t *testing.T) {
	compiler := NewCompiler()
	
	// Test basic indentation
	compiler.writeLine("def test():")
	compiler.indent++
	compiler.writeLine("pass")
	compiler.indent--
	
	output := compiler.output.String()
	lines := strings.Split(strings.TrimSpace(output), "\n")
	
	assert.Equal(t, "def test():", lines[0])
	assert.Equal(t, "    pass", lines[1])
}