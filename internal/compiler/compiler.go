package compiler

import (
	"fmt"
	"strings"

	"github.com/ayutaz/grimoire/internal/parser"
)

// Compiler generates code from AST
type Compiler struct {
	indent      int
	indentStr   string
	output      strings.Builder
}

// NewCompiler creates a new compiler
func NewCompiler() *Compiler {
	return &Compiler{
		indent:    0,
		indentStr: "    ", // 4 spaces
	}
}

// Compile generates Python code from AST
func Compile(ast *parser.Program) (string, error) {
	compiler := NewCompiler()
	return compiler.Compile(ast)
}

// Compile performs the compilation
func (c *Compiler) Compile(ast *parser.Program) (string, error) {
	c.output.Reset()

	// Add header comment
	c.writeLine("#!/usr/bin/env python3")
	c.writeLine("# Generated by Grimoire")
	c.writeLine("")

	// Compile globals
	for _, stmt := range ast.Globals {
		c.compileStatement(stmt)
	}

	// Compile functions
	for _, fn := range ast.Functions {
		c.compileFunction(fn)
		c.writeLine("")
	}

	// Compile main entry
	if ast.MainEntry != nil {
		if ast.MainEntry.IsMain {
			// Generate main block
			c.writeLine("if __name__ == \"__main__\":")
			c.indent++
			for _, stmt := range ast.MainEntry.Body {
				c.compileStatement(stmt)
			}
			c.indent--
		} else {
			c.compileFunction(ast.MainEntry)
		}
	}

	return c.output.String(), nil
}

// writeLine writes a line with proper indentation
func (c *Compiler) writeLine(line string) {
	if line == "" {
		c.output.WriteString("\n")
		return
	}
	
	for i := 0; i < c.indent; i++ {
		c.output.WriteString(c.indentStr)
	}
	c.output.WriteString(line)
	c.output.WriteString("\n")
}

// compileFunction compiles a function definition
func (c *Compiler) compileFunction(fn *parser.FunctionDef) {
	// Function header
	name := fn.Name
	if name == "" {
		name = "anonymous_func"
	}
	
	params := []string{}
	for _, p := range fn.Parameters {
		params = append(params, p.Name)
	}
	
	c.writeLine(fmt.Sprintf("def %s(%s):", name, strings.Join(params, ", ")))
	c.indent++
	
	// Function body
	if len(fn.Body) == 0 {
		c.writeLine("pass")
	} else {
		for _, stmt := range fn.Body {
			c.compileStatement(stmt)
		}
	}
	
	c.indent--
}

// compileStatement compiles a statement
func (c *Compiler) compileStatement(stmt parser.Statement) {
	switch s := stmt.(type) {
	case *parser.OutputStatement:
		c.compileOutputStatement(s)
	case *parser.Assignment:
		c.compileAssignment(s)
	case *parser.IfStatement:
		c.compileIfStatement(s)
	case *parser.ForLoop:
		c.compileForLoop(s)
	case *parser.WhileLoop:
		c.compileWhileLoop(s)
	case *parser.ParallelBlock:
		c.compileParallelBlock(s)
	case *parser.ReturnStatement:
		c.compileReturnStatement(s)
	case *parser.ExpressionStatement:
		expr := c.compileExpression(s.Expression)
		c.writeLine(expr)
	}
}

// compileOutputStatement compiles an output statement
func (c *Compiler) compileOutputStatement(stmt *parser.OutputStatement) {
	expr := c.compileExpression(stmt.Value)
	c.writeLine(fmt.Sprintf("print(%s)", expr))
}

// compileAssignment compiles an assignment
func (c *Compiler) compileAssignment(stmt *parser.Assignment) {
	target := stmt.Target.Name
	value := c.compileExpression(stmt.Value)
	c.writeLine(fmt.Sprintf("%s = %s", target, value))
}

// compileIfStatement compiles an if statement
func (c *Compiler) compileIfStatement(stmt *parser.IfStatement) {
	condition := c.compileExpression(stmt.Condition)
	c.writeLine(fmt.Sprintf("if %s:", condition))
	c.indent++
	
	if len(stmt.ThenBranch) == 0 {
		c.writeLine("pass")
	} else {
		for _, s := range stmt.ThenBranch {
			c.compileStatement(s)
		}
	}
	c.indent--
	
	if len(stmt.ElseBranch) > 0 {
		c.writeLine("else:")
		c.indent++
		for _, s := range stmt.ElseBranch {
			c.compileStatement(s)
		}
		c.indent--
	}
}

// compileForLoop compiles a for loop
func (c *Compiler) compileForLoop(stmt *parser.ForLoop) {
	counter := stmt.Counter.Name
	start := c.compileExpression(stmt.Start)
	end := c.compileExpression(stmt.End)
	
	var step string
	if stmt.Step != nil {
		step = c.compileExpression(stmt.Step)
		c.writeLine(fmt.Sprintf("for %s in range(%s, %s, %s):", counter, start, end, step))
	} else {
		c.writeLine(fmt.Sprintf("for %s in range(%s, %s):", counter, start, end))
	}
	
	c.indent++
	if len(stmt.Body) == 0 {
		c.writeLine("pass")
	} else {
		for _, s := range stmt.Body {
			c.compileStatement(s)
		}
	}
	c.indent--
}

// compileWhileLoop compiles a while loop
func (c *Compiler) compileWhileLoop(stmt *parser.WhileLoop) {
	condition := c.compileExpression(stmt.Condition)
	c.writeLine(fmt.Sprintf("while %s:", condition))
	c.indent++
	
	if len(stmt.Body) == 0 {
		c.writeLine("pass")
	} else {
		for _, s := range stmt.Body {
			c.compileStatement(s)
		}
	}
	c.indent--
}

// compileParallelBlock compiles parallel execution (using threading)
func (c *Compiler) compileParallelBlock(stmt *parser.ParallelBlock) {
	c.writeLine("import threading")
	c.writeLine("threads = []")
	
	for i, branch := range stmt.Branches {
		c.writeLine(fmt.Sprintf("def branch_%d():", i))
		c.indent++
		for _, s := range branch {
			c.compileStatement(s)
		}
		c.indent--
		c.writeLine(fmt.Sprintf("threads.append(threading.Thread(target=branch_%d))", i))
	}
	
	c.writeLine("for t in threads:")
	c.indent++
	c.writeLine("t.start()")
	c.indent--
	c.writeLine("for t in threads:")
	c.indent++
	c.writeLine("t.join()")
	c.indent--
}

// compileReturnStatement compiles a return statement
func (c *Compiler) compileReturnStatement(stmt *parser.ReturnStatement) {
	if stmt.Value != nil {
		value := c.compileExpression(stmt.Value)
		c.writeLine(fmt.Sprintf("return %s", value))
	} else {
		c.writeLine("return")
	}
}

// compileExpression compiles an expression
func (c *Compiler) compileExpression(expr parser.Expression) string {
	switch e := expr.(type) {
	case *parser.BinaryOp:
		return c.compileBinaryOp(e)
	case *parser.UnaryOp:
		return c.compileUnaryOp(e)
	case *parser.Literal:
		return c.compileLiteral(e)
	case *parser.Identifier:
		return e.Name
	case *parser.FunctionCall:
		return c.compileFunctionCall(e)
	case *parser.ArrayLiteral:
		return c.compileArrayLiteral(e)
	case *parser.MapLiteral:
		return c.compileMapLiteral(e)
	default:
		return "None"
	}
}

// compileBinaryOp compiles a binary operation
func (c *Compiler) compileBinaryOp(op *parser.BinaryOp) string {
	left := c.compileExpression(op.Left)
	right := c.compileExpression(op.Right)
	
	var operator string
	switch op.Operator {
	case parser.Add:
		operator = "+"
	case parser.Subtract:
		operator = "-"
	case parser.Multiply:
		operator = "*"
	case parser.Divide:
		operator = "/"
	case parser.Equal:
		operator = "=="
	case parser.NotEqual:
		operator = "!="
	case parser.LessThan:
		operator = "<"
	case parser.GreaterThan:
		operator = ">"
	case parser.LessEqual:
		operator = "<="
	case parser.GreaterEqual:
		operator = ">="
	case parser.And:
		operator = "and"
	case parser.Or:
		operator = "or"
	default:
		operator = "+"
	}
	
	return fmt.Sprintf("(%s %s %s)", left, operator, right)
}

// compileUnaryOp compiles a unary operation
func (c *Compiler) compileUnaryOp(op *parser.UnaryOp) string {
	operand := c.compileExpression(op.Operand)
	
	switch op.Operator {
	case parser.Not:
		return fmt.Sprintf("not %s", operand)
	default:
		return operand
	}
}

// compileLiteral compiles a literal value
func (c *Compiler) compileLiteral(lit *parser.Literal) string {
	switch lit.LiteralType {
	case parser.String:
		return fmt.Sprintf("%q", lit.Value)
	case parser.Boolean:
		if lit.Value.(bool) {
			return "True"
		}
		return "False"
	default:
		return fmt.Sprintf("%v", lit.Value)
	}
}

// compileFunctionCall compiles a function call
func (c *Compiler) compileFunctionCall(call *parser.FunctionCall) string {
	args := []string{}
	for _, arg := range call.Arguments {
		args = append(args, c.compileExpression(arg))
	}
	return fmt.Sprintf("%s(%s)", call.Function.Name, strings.Join(args, ", "))
}

// compileArrayLiteral compiles an array literal
func (c *Compiler) compileArrayLiteral(arr *parser.ArrayLiteral) string {
	elements := []string{}
	for _, elem := range arr.Elements {
		elements = append(elements, c.compileExpression(elem))
	}
	return fmt.Sprintf("[%s]", strings.Join(elements, ", "))
}

// compileMapLiteral compiles a map literal
func (c *Compiler) compileMapLiteral(m *parser.MapLiteral) string {
	pairs := []string{}
	for _, pair := range m.Pairs {
		key := c.compileExpression(pair[0])
		value := c.compileExpression(pair[1])
		pairs = append(pairs, fmt.Sprintf("%s: %s", key, value))
	}
	return fmt.Sprintf("{%s}", strings.Join(pairs, ", "))
}