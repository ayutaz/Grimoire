"""
Unit tests for code_generator module following TDD principles
Based on t-wada's testing approach with AAA pattern
"""

import pytest
import textwrap

from grimoire.code_generator import PythonCodeGenerator
from grimoire.ast_nodes import (
    Program, FunctionDef, Parameter, Assignment, IfStatement,
    WhileLoop, ForLoop, ParallelBlock, OutputStatement, ReturnStatement,
    ExpressionStatement, BinaryOp, UnaryOp, Literal, Identifier,
    FunctionCall, ArrayLiteral, MapLiteral, ArrayAccess, MapAccess,
    DataType, OperatorType
)


class TestPythonCodeGenerator:
    """Test PythonCodeGenerator class following TDD principles"""
    
    def setup_method(self):
        """Set up test fixtures (Arrange phase for all tests)"""
        self.generator = PythonCodeGenerator()
    
    def test_generator_initialization(self):
        """Test generator initializes with correct defaults"""
        # Assert
        assert self.generator.code == []
        assert self.generator.indent_level == 0
        assert self.generator.function_counter == 0
    
    def test_generate_empty_program(self):
        """Test generating code for empty program"""
        # Arrange
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "#!/usr/bin/env python3" in code
        assert "# Generated by Grimoire compiler" in code
        assert "import sys" in code
        assert "from concurrent.futures import ThreadPoolExecutor" in code
    
    def test_generate_hello_world(self):
        """Test generating hello world program"""
        # Arrange
        output_stmt = OutputStatement(
            value=Literal(value="Hello, World!", literal_type=DataType.STRING)
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[output_stmt]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "if __name__ == '__main__':" in code
        assert 'print("Hello, World!")' in code
    
    def test_generate_main_function(self):
        """Test generating main function"""
        # Arrange
        output_stmt = OutputStatement(
            value=Literal(value="From main", literal_type=DataType.STRING)
        )
        main_func = FunctionDef(
            name=None,
            parameters=[],
            body=[output_stmt],
            return_type=None,
            is_main=True
        )
        program = Program(
            has_outer_circle=True,
            main_entry=main_func,
            functions=[],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "def main():" in code
        assert 'print("From main")' in code
        assert "main()" in code
    
    def test_generate_function_with_parameters(self):
        """Test generating function with parameters"""
        # Arrange
        func = FunctionDef(
            name="add",
            parameters=[
                Parameter(name="a", data_type=DataType.INTEGER),
                Parameter(name="b", data_type=DataType.INTEGER)
            ],
            body=[
                ReturnStatement(
                    value=BinaryOp(
                        left=Identifier(name="a"),
                        operator=OperatorType.ADD,
                        right=Identifier(name="b")
                    )
                )
            ],
            return_type=DataType.INTEGER,
            is_main=False
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[func],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "def add(a, b):" in code
        assert "return (a + b)" in code
    
    def test_generate_anonymous_function(self):
        """Test generating anonymous function with auto-generated name"""
        # Arrange
        func = FunctionDef(
            name=None,  # Anonymous
            parameters=[],
            body=[OutputStatement(value=Literal(value="Anonymous", literal_type=DataType.STRING))],
            return_type=None,
            is_main=False
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[func],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "def func_0():" in code
        assert 'print("Anonymous")' in code
    
    def test_generate_assignment(self):
        """Test generating assignment statement"""
        # Arrange
        assignment = Assignment(
            target=Identifier(name="x"),
            value=Literal(value=42, literal_type=DataType.INTEGER)
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[assignment]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "x = 42" in code
    
    def test_generate_if_statement(self):
        """Test generating if statement"""
        # Arrange
        if_stmt = IfStatement(
            condition=BinaryOp(
                left=Identifier(name="x"),
                operator=OperatorType.GREATER_THAN,
                right=Literal(value=0, literal_type=DataType.INTEGER)
            ),
            then_branch=[
                OutputStatement(value=Literal(value="Positive", literal_type=DataType.STRING))
            ],
            else_branch=[
                OutputStatement(value=Literal(value="Non-positive", literal_type=DataType.STRING))
            ]
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[if_stmt]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "if (x > 0):" in code
        assert 'print("Positive")' in code
        assert "else:" in code
        assert 'print("Non-positive")' in code
    
    def test_generate_while_loop(self):
        """Test generating while loop"""
        # Arrange
        while_loop = WhileLoop(
            condition=BinaryOp(
                left=Identifier(name="count"),
                operator=OperatorType.LESS_THAN,
                right=Literal(value=10, literal_type=DataType.INTEGER)
            ),
            body=[
                Assignment(
                    target=Identifier(name="count"),
                    value=BinaryOp(
                        left=Identifier(name="count"),
                        operator=OperatorType.ADD,
                        right=Literal(value=1, literal_type=DataType.INTEGER)
                    )
                )
            ]
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[while_loop]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "while (count < 10):" in code
        assert "count = (count + 1)" in code
    
    def test_generate_for_loop(self):
        """Test generating for loop"""
        # Arrange
        for_loop = ForLoop(
            counter=Identifier(name="i"),
            start=Literal(value=0, literal_type=DataType.INTEGER),
            end=Literal(value=5, literal_type=DataType.INTEGER),
            step=Literal(value=1, literal_type=DataType.INTEGER),
            body=[
                OutputStatement(value=Identifier(name="i"))
            ]
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[for_loop]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "for i in range(0, 5, 1):" in code
        assert "print(i)" in code
    
    def test_generate_for_loop_default_step(self):
        """Test generating for loop with default step"""
        # Arrange
        for_loop = ForLoop(
            counter=Identifier(name="j"),
            start=Literal(value=1, literal_type=DataType.INTEGER),
            end=Literal(value=10, literal_type=DataType.INTEGER),
            step=None,  # Default step
            body=[OutputStatement(value=Identifier(name="j"))]
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[for_loop]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "for j in range(1, 10):" in code
        assert "print(j)" in code
    
    def test_generate_parallel_block(self):
        """Test generating parallel block"""
        # Arrange
        parallel_block = ParallelBlock(
            branches=[
                [OutputStatement(value=Literal(value="Branch 1", literal_type=DataType.STRING))],
                [OutputStatement(value=Literal(value="Branch 2", literal_type=DataType.STRING))]
            ]
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[parallel_block]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "# Parallel execution block" in code
        assert "with ThreadPoolExecutor() as executor:" in code
        assert "def branch_0():" in code
        assert "def branch_1():" in code
        assert "futures.append(executor.submit(branch_0))" in code
        assert "futures.append(executor.submit(branch_1))" in code
        assert "for future in as_completed(futures):" in code
    
    def test_generate_expression_literals(self):
        """Test generating literal expressions"""
        # Arrange
        test_cases = [
            (Literal(value=42, literal_type=DataType.INTEGER), "42"),
            (Literal(value=3.14, literal_type=DataType.FLOAT), "3.14"),
            (Literal(value="hello", literal_type=DataType.STRING), "'hello'"),
            (Literal(value=True, literal_type=DataType.BOOLEAN), "True"),
            (Literal(value=False, literal_type=DataType.BOOLEAN), "False"),
        ]
        
        for literal, expected in test_cases:
            # Act
            result = self.generator._generate_expression(literal)
            
            # Assert
            assert result == expected
    
    def test_generate_binary_operations(self):
        """Test generating binary operations"""
        # Arrange
        test_cases = [
            (OperatorType.ADD, "+"),
            (OperatorType.SUBTRACT, "-"),
            (OperatorType.MULTIPLY, "*"),
            (OperatorType.DIVIDE, "/"),
            (OperatorType.EQUAL, "=="),
            (OperatorType.NOT_EQUAL, "!="),
            (OperatorType.LESS_THAN, "<"),
            (OperatorType.GREATER_THAN, ">"),
            (OperatorType.AND, "and"),
            (OperatorType.OR, "or"),
        ]
        
        for op_type, expected_op in test_cases:
            # Arrange
            binary_op = BinaryOp(
                left=Identifier(name="a"),
                operator=op_type,
                right=Identifier(name="b")
            )
            
            # Act
            result = self.generator._generate_expression(binary_op)
            
            # Assert
            assert result == f"(a {expected_op} b)"
    
    def test_generate_unary_operations(self):
        """Test generating unary operations"""
        # Arrange
        unary_op = UnaryOp(
            operator=OperatorType.NOT,
            operand=Identifier(name="flag")
        )
        
        # Act
        result = self.generator._generate_expression(unary_op)
        
        # Assert
        assert result == "not flag"
    
    def test_generate_function_call(self):
        """Test generating function call"""
        # Arrange
        func_call = FunctionCall(
            function=Identifier(name="print"),
            arguments=[
                Literal(value="Hello", literal_type=DataType.STRING),
                Identifier(name="name")
            ]
        )
        
        # Act
        result = self.generator._generate_expression(func_call)
        
        # Assert
        assert result == "print('Hello', name)"
    
    def test_generate_array_literal(self):
        """Test generating array literal"""
        # Arrange
        array_lit = ArrayLiteral(
            elements=[
                Literal(value=1, literal_type=DataType.INTEGER),
                Literal(value=2, literal_type=DataType.INTEGER),
                Literal(value=3, literal_type=DataType.INTEGER)
            ]
        )
        
        # Act
        result = self.generator._generate_expression(array_lit)
        
        # Assert
        assert result == "[1, 2, 3]"
    
    def test_generate_map_literal(self):
        """Test generating map literal"""
        # Arrange
        map_lit = MapLiteral(
            pairs=[
                (
                    Literal(value="name", literal_type=DataType.STRING),
                    Literal(value="Alice", literal_type=DataType.STRING)
                ),
                (
                    Literal(value="age", literal_type=DataType.STRING),
                    Literal(value=30, literal_type=DataType.INTEGER)
                )
            ]
        )
        
        # Act
        result = self.generator._generate_expression(map_lit)
        
        # Assert
        assert result == "{'name': 'Alice', 'age': 30}"
    
    def test_generate_array_access(self):
        """Test generating array access"""
        # Arrange
        array_access = ArrayAccess(
            array=Identifier(name="arr"),
            index=Literal(value=0, literal_type=DataType.INTEGER)
        )
        
        # Act
        result = self.generator._generate_expression(array_access)
        
        # Assert
        assert result == "arr[0]"
    
    def test_generate_map_access(self):
        """Test generating map access"""
        # Arrange
        map_access = MapAccess(
            map_expr=Identifier(name="person"),
            key=Literal(value="name", literal_type=DataType.STRING)
        )
        
        # Act
        result = self.generator._generate_expression(map_access)
        
        # Assert
        assert result == "person['name']"
    
    def test_empty_function_body(self):
        """Test generating function with empty body"""
        # Arrange
        func = FunctionDef(
            name="empty_func",
            parameters=[],
            body=[],  # Empty body
            return_type=None,
            is_main=False
        )
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[func],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "def empty_func():" in code
        assert "    pass" in code
    
    def test_complex_nested_program(self):
        """Test generating complex nested program"""
        # Arrange
        # Create a function that calculates factorial
        factorial_func = FunctionDef(
            name="factorial",
            parameters=[Parameter(name="n", data_type=DataType.INTEGER)],
            body=[
                IfStatement(
                    condition=BinaryOp(
                        left=Identifier(name="n"),
                        operator=OperatorType.LESS_EQUAL,
                        right=Literal(value=1, literal_type=DataType.INTEGER)
                    ),
                    then_branch=[
                        ReturnStatement(value=Literal(value=1, literal_type=DataType.INTEGER))
                    ],
                    else_branch=[
                        ReturnStatement(
                            value=BinaryOp(
                                left=Identifier(name="n"),
                                operator=OperatorType.MULTIPLY,
                                right=FunctionCall(
                                    function=Identifier(name="factorial"),
                                    arguments=[
                                        BinaryOp(
                                            left=Identifier(name="n"),
                                            operator=OperatorType.SUBTRACT,
                                            right=Literal(value=1, literal_type=DataType.INTEGER)
                                        )
                                    ]
                                )
                            )
                        )
                    ]
                )
            ],
            return_type=DataType.INTEGER,
            is_main=False
        )
        
        # Main function that uses factorial
        main_func = FunctionDef(
            name=None,
            parameters=[],
            body=[
                Assignment(
                    target=Identifier(name="result"),
                    value=FunctionCall(
                        function=Identifier(name="factorial"),
                        arguments=[Literal(value=5, literal_type=DataType.INTEGER)]
                    )
                ),
                OutputStatement(value=Identifier(name="result"))
            ],
            return_type=None,
            is_main=True
        )
        
        program = Program(
            has_outer_circle=True,
            main_entry=main_func,
            functions=[factorial_func],
            globals=[]
        )
        
        # Act
        code = self.generator.generate(program)
        
        # Assert
        assert "def factorial(n):" in code
        assert "if (n <= 1):" in code
        assert "return 1" in code
        assert "return (n * factorial((n - 1)))" in code
        assert "def main():" in code
        assert "result = factorial(5)" in code
        assert "print(result)" in code
    
    def test_indentation_levels(self):
        """Test proper indentation is maintained"""
        # Arrange
        nested_if = IfStatement(
            condition=Literal(value=True, literal_type=DataType.BOOLEAN),
            then_branch=[
                IfStatement(
                    condition=Literal(value=True, literal_type=DataType.BOOLEAN),
                    then_branch=[
                        OutputStatement(value=Literal(value="Nested", literal_type=DataType.STRING))
                    ],
                    else_branch=None
                )
            ],
            else_branch=None
        )
        
        program = Program(
            has_outer_circle=True,
            main_entry=None,
            functions=[],
            globals=[nested_if]
        )
        
        # Act
        code = self.generator.generate(program)
        lines = code.split('\n')
        
        # Assert
        # Find the nested print statement and check its indentation
        for i, line in enumerate(lines):
            if 'print("Nested")' in line:
                # Count leading spaces
                indent_count = len(line) - len(line.lstrip())
                # Should have 3 levels: main, first if, second if
                assert indent_count == 12  # 3 * 4 spaces