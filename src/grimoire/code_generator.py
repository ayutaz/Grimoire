"""Code generator for Grimoire - Generates Python code from AST"""

from typing import List
import textwrap

from .ast_nodes import *


class PythonCodeGenerator(ASTVisitor):
    """Generate Python code from Grimoire AST"""
    
    def __init__(self):
        self.code = []
        self.indent_level = 0
        self.function_counter = 0
    
    def generate(self, program: Program) -> str:
        """Generate Python code from program"""
        self.code = []
        self.indent_level = 0
        
        # Add header
        self._emit("#!/usr/bin/env python3")
        self._emit("# Generated by Grimoire compiler")
        self._emit("# Magic circle visual programming language")
        self._emit("")
        
        # Add imports
        self._emit("import sys")
        self._emit("from concurrent.futures import ThreadPoolExecutor, as_completed")
        self._emit("")
        
        # Generate functions
        for func in program.functions:
            self._generate_function(func)
            self._emit("")
        
        # Generate main entry
        if program.main_entry:
            self._generate_function(program.main_entry)
            self._emit("")
        
        # Generate global statements
        if program.globals or program.main_entry:
            self._emit("if __name__ == '__main__':")
            self.indent_level += 1
            
            for stmt in program.globals:
                stmt.accept(self)
            
            if program.main_entry:
                self._emit("main()")
            
            self.indent_level -= 1
        
        return '\n'.join(self.code)
    
    def _emit(self, line: str = ""):
        """Emit a line of code with proper indentation"""
        if line:
            self.code.append("    " * self.indent_level + line)
        else:
            self.code.append("")
    
    def _generate_function(self, func: FunctionDef):
        """Generate a function definition"""
        # Generate function name
        if func.is_main:
            func_name = "main"
        elif func.name:
            func_name = func.name
        else:
            func_name = f"func_{self.function_counter}"
            self.function_counter += 1
        
        # Generate parameters
        params = []
        for param in func.parameters:
            params.append(param.name)
        
        # Generate function header
        self._emit(f"def {func_name}({', '.join(params)}):")
        self.indent_level += 1
        
        # Generate function body
        if func.body:
            for stmt in func.body:
                stmt.accept(self)
        else:
            self._emit("pass")
        
        self.indent_level -= 1
    
    # Visitor methods
    
    def visit_program(self, node: Program):
        # Handled by generate()
        pass
    
    def visit_function_def(self, node: FunctionDef):
        self._generate_function(node)
    
    def visit_parameter(self, node: Parameter):
        # Handled in function generation
        pass
    
    def visit_expression_statement(self, node: ExpressionStatement):
        expr_code = self._generate_expression(node.expression)
        self._emit(expr_code)
    
    def visit_assignment(self, node: Assignment):
        target = node.target.name
        value = self._generate_expression(node.value)
        self._emit(f"{target} = {value}")
    
    def visit_if_statement(self, node: IfStatement):
        condition = self._generate_expression(node.condition)
        self._emit(f"if {condition}:")
        
        self.indent_level += 1
        if node.then_branch:
            for stmt in node.then_branch:
                stmt.accept(self)
        else:
            self._emit("pass")
        self.indent_level -= 1
        
        if node.else_branch:
            self._emit("else:")
            self.indent_level += 1
            for stmt in node.else_branch:
                stmt.accept(self)
            self.indent_level -= 1
    
    def visit_while_loop(self, node: WhileLoop):
        condition = self._generate_expression(node.condition)
        self._emit(f"while {condition}:")
        
        self.indent_level += 1
        if node.body:
            for stmt in node.body:
                stmt.accept(self)
        else:
            self._emit("pass")
        self.indent_level -= 1
    
    def visit_for_loop(self, node: ForLoop):
        counter = node.counter.name
        start = self._generate_expression(node.start)
        end = self._generate_expression(node.end)
        
        if node.step:
            step = self._generate_expression(node.step)
            self._emit(f"for {counter} in range({start}, {end}, {step}):")
        else:
            self._emit(f"for {counter} in range({start}, {end}):")
        
        self.indent_level += 1
        if node.body:
            for stmt in node.body:
                stmt.accept(self)
        else:
            self._emit("pass")
        self.indent_level -= 1
    
    def visit_parallel_block(self, node: ParallelBlock):
        self._emit("# Parallel execution block")
        self._emit("with ThreadPoolExecutor() as executor:")
        self.indent_level += 1
        
        self._emit("futures = []")
        
        # Generate function for each branch
        for i, branch in enumerate(node.branches):
            self._emit(f"def branch_{i}():")
            self.indent_level += 1
            for stmt in branch:
                stmt.accept(self)
            self.indent_level -= 1
            
            self._emit(f"futures.append(executor.submit(branch_{i}))")
        
        self._emit("# Wait for all branches")
        self._emit("for future in as_completed(futures):")
        self.indent_level += 1
        self._emit("future.result()")
        self.indent_level -= 1
        
        self.indent_level -= 1
    
    def visit_return_statement(self, node: ReturnStatement):
        if node.value:
            value = self._generate_expression(node.value)
            self._emit(f"return {value}")
        else:
            self._emit("return")
    
    def visit_output_statement(self, node: OutputStatement):
        value = self._generate_expression(node.value)
        self._emit(f"print({value})")
    
    def visit_binary_op(self, node: BinaryOp):
        # Handled in _generate_expression
        pass
    
    def visit_unary_op(self, node: UnaryOp):
        # Handled in _generate_expression
        pass
    
    def visit_literal(self, node: Literal):
        # Handled in _generate_expression
        pass
    
    def visit_identifier(self, node: Identifier):
        # Handled in _generate_expression
        pass
    
    def visit_function_call(self, node: FunctionCall):
        # Handled in _generate_expression
        pass
    
    def visit_array_literal(self, node: ArrayLiteral):
        # Handled in _generate_expression
        pass
    
    def visit_map_literal(self, node: MapLiteral):
        # Handled in _generate_expression
        pass
    
    def visit_array_access(self, node: ArrayAccess):
        # Handled in _generate_expression
        pass
    
    def visit_map_access(self, node: MapAccess):
        # Handled in _generate_expression
        pass
    
    def _generate_expression(self, expr: Expression) -> str:
        """Generate code for an expression"""
        if isinstance(expr, Literal):
            if expr.literal_type == DataType.STRING:
                return repr(expr.value)
            elif expr.literal_type == DataType.BOOLEAN:
                return "True" if expr.value else "False"
            else:
                return str(expr.value)
        
        elif isinstance(expr, Identifier):
            return expr.name
        
        elif isinstance(expr, BinaryOp):
            left = self._generate_expression(expr.left)
            right = self._generate_expression(expr.right)
            
            op_map = {
                OperatorType.ADD: "+",
                OperatorType.SUBTRACT: "-",
                OperatorType.MULTIPLY: "*",
                OperatorType.DIVIDE: "/",
                OperatorType.EQUAL: "==",
                OperatorType.NOT_EQUAL: "!=",
                OperatorType.LESS_THAN: "<",
                OperatorType.GREATER_THAN: ">",
                OperatorType.LESS_EQUAL: "<=",
                OperatorType.GREATER_EQUAL: ">=",
                OperatorType.AND: "and",
                OperatorType.OR: "or",
            }
            
            op = op_map.get(expr.operator, "+")
            return f"({left} {op} {right})"
        
        elif isinstance(expr, UnaryOp):
            operand = self._generate_expression(expr.operand)
            
            if expr.operator == OperatorType.NOT:
                return f"not {operand}"
            else:
                return operand
        
        elif isinstance(expr, FunctionCall):
            if isinstance(expr.function, FunctionDef):
                func_name = expr.function.name or f"func_{id(expr.function)}"
            else:
                func_name = expr.function.name
            
            args = [self._generate_expression(arg) for arg in expr.arguments]
            return f"{func_name}({', '.join(args)})"
        
        elif isinstance(expr, ArrayLiteral):
            elements = [self._generate_expression(elem) for elem in expr.elements]
            return f"[{', '.join(elements)}]"
        
        elif isinstance(expr, MapLiteral):
            pairs = []
            for key_expr, value_expr in expr.pairs:
                key = self._generate_expression(key_expr)
                value = self._generate_expression(value_expr)
                pairs.append(f"{key}: {value}")
            return f"{{{', '.join(pairs)}}}"
        
        elif isinstance(expr, ArrayAccess):
            array = self._generate_expression(expr.array)
            index = self._generate_expression(expr.index)
            return f"{array}[{index}]"
        
        elif isinstance(expr, MapAccess):
            map_expr = self._generate_expression(expr.map_expr)
            key = self._generate_expression(expr.key)
            return f"{map_expr}[{key}]"
        
        else:
            return "None"