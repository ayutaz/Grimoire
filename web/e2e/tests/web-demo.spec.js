const { test, expect } = require('@playwright/test');
const path = require('path');
const fs = require('fs');

test.describe('Grimoire Web Demo', () => {
  test.beforeEach(async ({ page }) => {
    // Enable console logging in CI
    if (process.env.CI) {
      page.on('console', msg => console.log(`Browser console: ${msg.type()}: ${msg.text()}`));
      page.on('pageerror', error => console.log(`Browser error: ${error}`));
    }
    
    console.log('Navigating to page...');
    await page.goto('/');
    
    console.log('Waiting for WebAssembly initialization...');
    // Wait for WebAssembly to initialize (Pyodide is optional)
    try {
      await page.waitForFunction(() => {
        console.log('Checking wasmInstance:', typeof window.wasmInstance);
        return window.wasmInstance !== undefined;
      }, { timeout: process.env.CI ? 15000 : 30000 });  // Shorter timeout in CI
      console.log('WebAssembly initialized successfully');
    } catch (error) {
      console.log('WASM initialization timeout, checking page state...');
      const pageContent = await page.content();
      console.log('Page title:', await page.title());
      console.log('Has wasm_exec.js:', pageContent.includes('wasm_exec.js'));
      console.log('Has app.js:', pageContent.includes('app.js'));
      throw error;
    }
  });

  test('should load the page correctly', async ({ page }) => {
    console.log('Testing page load...');
    await expect(page).toHaveTitle(/Grimoire.*Web Demo/);
    console.log('Title check passed');
    
    await expect(page.locator('h1')).toContainText('Grimoire');
    console.log('Header check passed');
    
    // execute-btn is initially hidden until an image is selected
    await expect(page.locator('.input-section')).toBeVisible();
    console.log('Input section check passed');
  });

  test.skip('should display sample images', async ({ page }) => {
    const sampleImages = ['hello-world', 'calculator', 'fibonacci', 'loop'];
    
    for (const sample of sampleImages) {
      const sampleElement = page.locator(`[data-sample="${sample}"]`);
      await expect(sampleElement).toBeVisible();
    }
  });

  test.skip('should process hello-world sample image', async ({ page }) => {
    // Click on hello-world sample
    await page.click('[data-sample="hello-world"]');
    
    // Wait for preview to show
    await expect(page.locator('#preview-image')).toBeVisible();
    
    // Click execute button
    await page.click('#execute-btn');
    
    // Wait for result
    await page.waitForSelector('.result-section', { state: 'visible', timeout: 10000 });
    
    // Check if Python code was generated
    const codeContent = await page.textContent('#code-content');
    expect(codeContent).toContain('#!/usr/bin/env python3');
    expect(codeContent).toContain('# Generated by Grimoire');
    
    // Check if output contains "Hello, World!" or similar
    // Note: The actual output depends on Pyodide execution
    const outputContent = await page.textContent('#output-content');
    expect(outputContent).toBeTruthy();
  });

  test.skip('should process loop sample image', async ({ page }) => {
    // Click on loop sample
    await page.click('[data-sample="loop"]');
    
    // Wait for preview
    await expect(page.locator('#preview-image')).toBeVisible();
    
    // Execute
    await page.click('#execute-btn');
    
    // Wait for result
    await page.waitForSelector('.result-section', { state: 'visible', timeout: 10000 });
    
    // Check if Python code was generated
    const codeContent = await page.textContent('#code-content');
    expect(codeContent).toBeTruthy();
    expect(codeContent).toContain('#!/usr/bin/env python3');
  });

  test.skip('should handle file upload', async ({ page }) => {
    // Create a test image file path
    const testImagePath = path.join(__dirname, '..', '..', 'static', 'samples', 'hello-world.png');
    
    // Upload file
    const fileInput = page.locator('#file-input');
    await fileInput.setInputFiles(testImagePath);
    
    // Wait for preview
    await expect(page.locator('#preview-image')).toBeVisible();
    
    // Execute
    await page.click('#execute-btn');
    
    // Wait for result
    await page.waitForSelector('.result-section', { state: 'visible', timeout: 10000 });
    
    // Verify code was generated
    const codeContent = await page.textContent('#code-content');
    expect(codeContent).toContain('#!/usr/bin/env python3');
  });

  test.skip('should switch between tabs', async ({ page }) => {
    // Process an image first
    await page.click('[data-sample="hello-world"]');
    await page.click('#execute-btn');
    await page.waitForSelector('.result-section', { state: 'visible' });
    
    // Check all tabs
    const tabs = ['output', 'code', 'ast'];
    
    for (const tab of tabs) {
      await page.click(`[data-tab="${tab}"]`);
      await expect(page.locator(`#${tab}-tab`)).toHaveClass(/active/);
    }
  });

  test.skip('should display debug information', async ({ page }) => {
    // Process an image
    await page.click('[data-sample="hello-world"]');
    await page.click('#execute-btn');
    await page.waitForSelector('.result-section', { state: 'visible' });
    
    // Switch to AST tab
    await page.click('[data-tab="ast"]');
    
    // Check if AST content is displayed
    const astContent = await page.textContent('#ast-content');
    expect(astContent).toBeTruthy();
    // AST should contain some content
    expect(astContent.length).toBeGreaterThan(0);
  });

  test.skip('should handle errors gracefully', async ({ page }) => {
    // Create an invalid image and try to process it
    const testImagePath = path.join(__dirname, '../test-image-invalid.png');
    
    // Create an invalid PNG file
    fs.writeFileSync(testImagePath, 'invalid image data');
    
    await page.setInputFiles('#file-input', testImagePath);
    
    // Wait for preview to show
    await page.waitForSelector('.preview-section', { state: 'visible' });
    
    // Try to execute
    await page.click('#execute-btn');
    
    // Should show error or handle gracefully
    // The error might be shown or the result might indicate failure
    await page.waitForTimeout(2000); // Give time for processing
    
    // Clean up
    fs.unlinkSync(testImagePath);
    
    // Just verify the page didn't crash
    await expect(page.locator('h1')).toContainText('Grimoire');
  });
});